<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fish-docs-jp</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="index.html">Documentation</a></li><li><a href="tutorial.html"><strong aria-hidden="true">1.</strong> チュートリアル</a></li><li><ol class="section"><li><a href="tutorial/why_fish.html"><strong aria-hidden="true">1.1.</strong> なぜfishなのか？</a></li><li><a href="tutorial/getting_started.html"><strong aria-hidden="true">1.2.</strong> はじめかた</a></li><li><a href="tutorial/learning_fish.html"><strong aria-hidden="true">1.3.</strong> fishを学ぶ</a></li><li><a href="tutorial/running_commands.html"><strong aria-hidden="true">1.4.</strong> コマンドの実行</a></li><li><a href="tutorial/getting_help.html"><strong aria-hidden="true">1.5.</strong> ヘルプを読む</a></li><li><a href="tutorial/syntax_highlighting.html"><strong aria-hidden="true">1.6.</strong> シンタックスハイライト</a></li><li><a href="tutorial/wildcards.html"><strong aria-hidden="true">1.7.</strong> ワイルドカード</a></li><li><a href="tutorial/pipes_and_redirections.html"><strong aria-hidden="true">1.8.</strong> パイプとリダイレクト</a></li><li><a href="tutorial/autosuggestions.html"><strong aria-hidden="true">1.9.</strong> オートサジェスト</a></li><li><a href="tutorial/tab_completions.html"><strong aria-hidden="true">1.10.</strong> タブ補完</a></li><li><a href="tutorial/variables.html"><strong aria-hidden="true">1.11.</strong> 変数</a></li><li><a href="tutorial/exit_status.html"><strong aria-hidden="true">1.12.</strong> 終了ステータス</a></li><li><a href="tutorial/shell_variables.html"><strong aria-hidden="true">1.13.</strong> エクスポート(シェル変数)</a></li><li><a href="tutorial/lists.html"><strong aria-hidden="true">1.14.</strong> リスト</a></li><li><a href="tutorial/command_substitutions.html"><strong aria-hidden="true">1.15.</strong> コマンド置換</a></li><li><a href="tutorial/separating_commands.html"><strong aria-hidden="true">1.16.</strong> セパレートコマンド(;)</a></li><li><a href="tutorial/combiners.html"><strong aria-hidden="true">1.17.</strong> コンバイナ(and, or, not)</a></li><li><a href="tutorial/conditionals.html"><strong aria-hidden="true">1.18.</strong> 条件式(if, else, switch)</a></li><li><a href="tutorial/functions.html"><strong aria-hidden="true">1.19.</strong> 関数</a></li><li><a href="tutorial/loops.html"><strong aria-hidden="true">1.20.</strong> ループ</a></li><li><a href="tutorial/prompt.html"><strong aria-hidden="true">1.21.</strong> プロンプト</a></li><li><a href="tutorial/path.html"><strong aria-hidden="true">1.22.</strong> PATH変数</a></li><li><a href="tutorial/startup.html"><strong aria-hidden="true">1.23.</strong> 起動に際して(.bashrc)</a></li><li><a href="tutorial/autoloading_functions.html"><strong aria-hidden="true">1.24.</strong> オートロード関数</a></li><li><a href="tutorial/universal_variables.html"><strong aria-hidden="true">1.25.</strong> ユニバーサル変数</a></li><li><a href="tutorial/switching_to_fish.html"><strong aria-hidden="true">1.26.</strong> fishをデフォルトシェルにする</a></li><li><a href="tutorial/ready_for_more.html"><strong aria-hidden="true">1.27.</strong> より多くを知るには</a></li></ol></li><li><a href="faq.html"><strong aria-hidden="true">2.</strong> FAQ</a></li><li><ol class="section"><li><a href="faq/environment_variable.html"><strong aria-hidden="true">2.1.</strong> 環境変数の追加, 削除をするには？</a></li><li><a href="faq/config_fish.html"><strong aria-hidden="true">2.2.</strong> ログイン時にコマンドを実行するには？ fishの.bashrcは？</a></li><li><a href="faq/prompt.html"><strong aria-hidden="true">2.3.</strong> 独自のプロンプトを設定するには？</a></li><li><a href="faq/history.html"><strong aria-hidden="true">2.4.</strong> 履歴からコマンドを実行するには？</a></li><li><a href="faq/subcommand.html"><strong aria-hidden="true">2.5.</strong> サブコマンドを実行するには？ バッククオートが動作しません！</a></li><li><a href="faq/single_long_string.html"><strong aria-hidden="true">2.6.</strong> pkg-configのような出力が1行の長い文字列のときどうしたらいい？</a></li><li><a href="faq/exit_status.html"><strong aria-hidden="true">2.7.</strong> コマンドの終了ステータスを得るには？</a></li><li><a href="faq/env_var_just_one.html"><strong aria-hidden="true">2.8.</strong> 一回限りの環境変数を設定するには？</a></li><li><a href="faq/var_defined.html"><strong aria-hidden="true">2.9.</strong> 変数が定義されるているか確認するには？</a></li><li><a href="faq/var_not_empty.html"><strong aria-hidden="true">2.10.</strong> 変数が空でないか確認するには？</a></li><li><a href="faq/set_ux.html"><strong aria-hidden="true">2.11.</strong> set -Ux(ユニバーサル変数のエクスポート)が働かない？</a></li><li><a href="faq/syntax_color.html"><strong aria-hidden="true">2.12.</strong> シンタックスハイライトの色を変えるには？</a></li><li><a href="faq/man_update.html"><strong aria-hidden="true">2.13.</strong> manページの補完をアップデートするには？</a></li><li><a href="faq/change_directory.html"><strong aria-hidden="true">2.14.</strong> 間違ってディレクトリのパスを打ってEnter押したらディレクトリが移動してしまいました. 何が起きたの？</a></li><li><a href="faq/open_not_work.html"><strong aria-hidden="true">2.15.</strong> オープンコマンドが働きません</a></li><li><a href="faq/default_shell.html"><strong aria-hidden="true">2.16.</strong> fishをデフォルトシェルにするには？</a></li><li><a href="faq/weird_output_screen.html"><strong aria-hidden="true">2.17.</strong> screenを使ってるとき, プロンプトの前に変な出力がでます</a></li><li><a href="faq/greeting.html"><strong aria-hidden="true">2.18.</strong> グリーティングメッセージを変更するには？</a></li><li><a href="faq/history_substitution.html"><strong aria-hidden="true">2.19.</strong> 履歴置換(!$など)が働かないのはなぜ？</a></li><li><a href="faq/shortcut_cd.html"><strong aria-hidden="true">2.20.</strong> -をcd -のショートカットとして使うには？</a></li><li><a href="faq/uninstall.html"><strong aria-hidden="true">2.21.</strong> アンインストールするには？</a></li><li><a href="faq/unicode_puc.html"><strong aria-hidden="true">2.22.</strong> fishのUnicode private-use charactersについて</a></li><li><a href="faq/extra_tools.html"><strong aria-hidden="true">2.23.</strong> fishの拡張機能を探すには？</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">fish-docs-jp</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#documentation" id="documentation"><h1>Documentation</h1></a>
<a class="header" href="#チュートリアル" id="チュートリアル"><h1>チュートリアル</h1></a>
<a class="header" href="#なぜfishなのか" id="なぜfishなのか"><h2>なぜfishなのか？</h2></a>
<p><code>fish</code>はbashやzshのように完備で, 気の利いたユーザーフレンドリーなコマンドラインシェルです.
<code>fish</code>はシンタックスハイライト, オートサジェスト, タブ補完といった強力な機能を学習したり
設定をいじったりすることなく利用することができます.</p>
<p>コマンドラインを難しい構文を覚えたり設定ファイルを書いたりすることなくもっと生産的に, 便利に, 楽しくしたいなら<code>fish</code>こそが探し求めていたものになるでしょう！</p>
<a class="header" href="#はじめかた" id="はじめかた"><h2>はじめかた</h2></a>
<p>一度インストールしてしまえば今使っているシェルで<code>fish</code>とタイプするだけで試してみることができます！</p>
<p>起動するとfishのプロンプトが表示されます.
これはもう準備ができていてfishを始めることができることを意味しています.</p>
<pre><code class="language-fish">&gt; fish
Welcome to fish, the friendly interactive shell
Type help for instructions on how to use fish
you@hostname ~&gt;____
</code></pre>
<p>このプロンプトは<code>fish</code>のデフォルトのプロンプトで, あなたのユーザーネーム, ホストネーム,
それからワーキングディレクトリを表示しています.</p>
<ul>
<li>プロンプトを変えるためには[プロンプトの変えかた]</li>
<li>fishをログインシェルにするには[デフォルトシェルをfishに変える]</li>
</ul>
<p>を読んでください.</p>
<p>以降, プロンプトは簡単のため'<code>&gt;_</code>'で表します.</p>
<a class="header" href="#fishを学ぶ" id="fishを学ぶ"><h2>fishを学ぶ</h2></a>
<p>このチュートリアルではコマンドラインシェルとUnixコマンドの基本的な理解と, fishが動く環境を前提としています.</p>
<p>もし他のシェルのことをよく知っていて, <code>fish</code>がそれとどう異なるのかを知りたい場合は<em>他のシェルと違って</em>というフレーズを検索してください.
これは重要な違いを示す時に使われています.</p>
<a class="header" href="#コマンドの実行" id="コマンドの実行"><h2>コマンドの実行</h2></a>
<p><code>fish</code>は他のシェルと同じように, コマンドに続けて引数を与えることで実行します.
スペースはセパレータとなっています.</p>
<pre><code class="language-fish">&gt;_ echo hello world
hello world
</code></pre>
<p>空白文字として引数を与えたい場合, バックスラッシュを前置するか或いはシングルクオート,
ダブルクオートで囲むことによって実現します.</p>
<pre><code class="language-fish">&gt;_ mkdir My\ Files
&gt;_ cp ~/Some\ File 'My Files'
&gt;_ ls &quot;My Files&quot;
Some File
</code></pre>
<p>コマンドはセミコロンを用いることによって繋げることができます.</p>
<a class="header" href="#ヘルプを読む" id="ヘルプを読む"><h2>ヘルプを読む</h2></a>
<p><code>fish</code>には素晴らしいhelpとmanページが備わっています.
<code>help</code>コマンドを実行するとウェブブラウザでヘルプを開き, <code>man</code>コマンドはターミナル上でmanページを開きます.
特定のコマンドについてのヘルプを読むこともでき, 例えば<code>help set</code>とすればウェブブラウザで,
<code>mans set</code>とすればターミナルで読むことができます.</p>
<pre><code class="language-fish">&gt;_ man set
set - handle shell variables
  Synopsis...
</code></pre>
<a class="header" href="#シンタックスハイライト" id="シンタックスハイライト"><h2>シンタックスハイライト</h2></a>
<p><code>fish</code>を使っているとタイプするに従ってシンタックスハイライトが効いていることに
すぐに気がつくでしょう.
無効なコマンドはデフォルトでは赤く表示されます.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;/bin/mkd&lt;/eror&gt;
</code></pre>
<p>コマンドが存在しない或いは実行可能でない場合に無効となり, 有効になると色が変化します.</p>
<pre><code class="language-fish">&gt;_ /bin/mkdir
</code></pre>
<p><code>fish</code>はファイルパスが有効なとき下線を示すでしょう.</p>
<pre><code class="language-fish">&gt;_ cat &lt;u&gt;~/somefi&lt;/u&gt;___
</code></pre>
<p>これは'<code>somefi</code>'から始まるファイルが存在していることを示していて, タイピングの補助となります.</p>
<p>これらのシンタックスハイライトは他にもたくさんありますが, <code>fish_config</code>を変更したり
変数を直接編集することによって色を変えることができます.</p>
<a class="header" href="#ワイルドカード" id="ワイルドカード"><h2>ワイルドカード</h2></a>
<p><code>fish</code>はワイルドカードの<code>*</code>をサポートしています.
全てのJPEGファイルをリストアップするには次のようにします.</p>
<pre><code class="language-fish">&gt;_ ls *.jpg
lena.jpg
meena.jpg
santa maria.jpg
</code></pre>
<p>複数のワイルドカードを用いることもできます.</p>
<pre><code class="language-fish">&gt;_ ls l*.p*
lena.png
lesson.pdf
</code></pre>
<p>特に強力なのはディレクトリを再帰的に探索する<code>**</code>です.</p>
<pre><code class="language-fish">&gt;_ ls /var/**.log
/var/log/system.log
/var/run/sntp.log
</code></pre>
<p>ディレクトリの探査に時間がかかるときは<code>Ctrl-c</code>で中止することができます.</p>
<a class="header" href="#パイプとリダイレクト" id="パイプとリダイレクト"><h2>パイプとリダイレクト</h2></a>
<p><code>|</code>を用いることでコマンドをパイプすることができます.</p>
<pre><code class="language-fish">&gt;_ echo hello world | wc
       1       2      12
</code></pre>
<p>stdinとstdoutは馴染み深い<code>&lt;</code>と<code>&gt;</code>によってリダイレクトすることができます.
stderrは<code>2&gt;</code>によってリダイレクトされます.</p>
<pre><code class="language-fish">&gt;_ grep fish &lt; /etc/shells &gt; ~/output.txt 2&gt; ~/errors.txt
</code></pre>
<a class="header" href="#オートサジェスト" id="オートサジェスト"><h2>オートサジェスト</h2></a>
<p><code>fish</code>はタイプに従ってコマンドをサジェストします.
サジェストされた結果はカーソルの右側に灰色で示されます.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;/bin/h&lt;/eror&gt;&lt;s&gt;___ostname&lt;/s&gt;
</code></pre>
<p>パスやオプションをサジェストすることもできます.</p>
<pre><code class="language-fish">&gt;_ grep --i&lt;s&gt;___gnore-case&lt;/s&gt;
</code></pre>
<p>もちろん履歴にもはたらきます. 一度コマンドを実行したことがあれば, 数文字タイプしただけで再度
実行することができます.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;r&lt;&lt;/eror&gt;&lt;s&gt;___sync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo&lt;/s&gt;
</code></pre>
<p>サジェストの結果を利用するには<code>→</code>または<code>Ctrl-f</code>を押してください.
最初の1語だけを利用したい場合は<code>Alt-→</code>を押してください.
また, サジェストが求めているものと異なればそのまま無視して構いません.</p>
<a class="header" href="#タブ補完" id="タブ補完"><h2>タブ補完</h2></a>
<p><code>fish</code>はすぐに使えるリッチなタブ補完を備えています.
<code>tab</code>を押してみると, <code>fish</code>はコマンドや引数, パスを補完しようとするでしょう.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;/pri&lt;/eror&gt; :kbd:`Tab` =&gt; /private
</code></pre>
<p>複数の候補が見つかれば, それらをリストとして表示します.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;~/stuff/s&lt;/eror&gt; :kbd:`Tab`
&lt;mtch&gt;~/stuff/script.sh  &lt;i&gt;(Executable, 4.8kB)&lt;/i&gt;  \mtch{~/stuff/s&lt;/mtch&gt;ources/  &lt;i&gt;(Directory)&lt;/i&gt;}
</code></pre>
<p><code>tab</code>を押すたびにその候補を順にフォーカスします.</p>
<p><code>fish</code>はgitのブランチのようなものまでも補完することができます.</p>
<pre><code class="language-fish">&gt;_ git merge pr :kbd:`Tab` =&gt; git merge prompt_designer
&gt;_ git checkout b :kbd:`Tab`
&lt;mtch&gt;builtin_list_io_merge &lt;i&gt;(Branch)&lt;/i&gt; \mtch{b&lt;/mtch&gt;uiltin_set_color &lt;i&gt;(Branch)&lt;/i&gt; &lt;mtch&gt;b&lt;/mtch&gt;usted_events &lt;i&gt;(Tag)&lt;/i&gt;}
</code></pre>
<p>実際に<code>tab</code>を押して確認してみましょう！</p>
<a class="header" href="#変数" id="変数"><h2>変数</h2></a>
<p>他のシェルと同じように, <code>$</code>によって変数を扱います.</p>
<pre><code class="language-fish">&gt;_ echo My home directory is $HOME
My home directory is /home/tutorial
</code></pre>
<p>変数はダブルクオートのなかでは置換されますが, シングルクオートの中では置換されません.</p>
<pre><code class="language-fish">&gt;_ echo &quot;My current directory is $PWD&quot;
My current directory is /home/tutorial
&gt;_ echo 'My current directory is $PWD'
My current directory is $PWD
</code></pre>
<p>他のシェルと違って, <code>fish</code>は変数を代入する構文を持ちません.
代わりに変数名とその値を引数にとる, <code>set</code>コマンドを持ちます.</p>
<pre><code class="language-fish">&gt;_ set name 'Mister Noodle'
&gt;_ echo $name
Mister Noodle
</code></pre>
<p>(クオートに注意してください. もしこれがなければ<code>Mister</code>と<code>Noodle</code>は別々の引数として認識され, <code>$name</code>は2つの要素を持つリストになります.)</p>
<p>他のシェルと違って, 変数は置換後に分割されることはありません.</p>
<pre><code class="language-fish">&gt;_ mkdir $name
&gt;_ ls
Mister Noodle
</code></pre>
<p>bashでは上記コマンドで&quot;Mister&quot;と&quot;Noodle&quot;という2つのディレクトリが作られます.
<code>fish</code>では&quot;Mister Noodle&quot;という値を持った変数によって1つのディレクトリが作られます.
つまり<code>mkdir</code>にはスペースを含んだ文字列の引数として渡されます.
他のシェルではリストという表現ではなく&quot;配列&quot;という用語が用いられます.</p>
<a class="header" href="#終了ステータス" id="終了ステータス"><h2>終了ステータス</h2></a>
<p>他のシェルと違って, <code>fish</code>は直前に実行したコマンドの終了ステータスを<code>$?</code>ではなく<code>$status</code>という変数に格納します.</p>
<pre><code class="language-fish">&gt;_ false
&gt;_ echo $status
1
</code></pre>
<p>0は成功, それ以外はエラーを表します.
<code>$pipestatus</code>というパイプの過程の終了ステータスを格納する配列の変数もあります.</p>
<a class="header" href="#エクスポートシェル変数" id="エクスポートシェル変数"><h2>エクスポート(シェル変数)</h2></a>
<p>他のシェルと違って, <code>fish</code>は<code>export</code>コマンドをサポートしていません.
代わりに<code>set</code>コマンドの<code>--export</code>或いは<code>-x</code>オプションによって変数をエクスポートします.</p>
<pre><code class="language-fish">&gt;_ set -x MyVariable SomeValue
&gt;_ env | grep MyVariable
MyVariable=SomeValue
</code></pre>
<p>変数は<code>-e</code>若しくは<code>--erase</code>オプションによって削除することができます.</p>
<pre><code class="language-fish">&gt;_ set -e MyVariable
&gt;_ env | grep MyVariable
(no output)
</code></pre>
<a class="header" href="#リスト" id="リスト"><h2>リスト</h2></a>
<p>先に見た<code>set</code>コマンドはクオートで囲むことによって<code>Mister Noodle</code>を1つの引数として扱いました.
もし2つの引数だったなら, 変数<code>name</code>は長さ2のリストになります.
実際, <code>fish</code>の全ての変数はリストであり, いくつでも値を保持できるし全く持たないことも可能です.</p>
<p><code>$PWD</code>のようないくつかの変数は1つしか値を持ちません.
慣習に従って変数の値というとき, 最初(かつただ1つ)の値を指すことにします.</p>
<p><code>$PATH</code>のようなその他の変数は複数の値を保持しています.
これらの変数は複数の引数として展開されます.</p>
<pre><code class="language-fish">&gt;_ echo $PATH
/usr/bin /bin /usr/sbin /sbin /usr/local/bin
</code></pre>
<p>&quot;PATH&quot;で終わる変数は自動的にコロンで分割されてリストになります.
これらはサブコマンドに渡されるときにコロンによって結合されます.
この仕様は<code>$PATH</code>はコロンで区切られていると想定している他のツールとの互換性のためにあります.
明示的にパスを変数に加えるには<code>set --path</code>, 削除するには<code>set --unpath</code>を用いることができます.</p>
<p>リストは要素として他のリストを保持することはできず, 再帰的ではありません.
変数は文字列のリストであり, 他にはありえません</p>
<p>リストの要素数を得るには<code>count</code>コマンドを使います.</p>
<pre><code class="language-fish">&gt;_ count $PATH
5
</code></pre>
<p>リスト自身に追加の引数をセットすることで, 要素を追加することができます.
<code>$PATH</code>に<code>/usr/local/bin</code>を追加する例を示します.</p>
<pre><code class="language-fish">&gt;_ set PATH $PATH /usr/local/bin
</code></pre>
<p><code>[]</code>を用いることで個別の要素にアクセスすることができます.
インデックスは1から始まり, 最後は-1です.</p>
<pre><code class="language-fish">&gt;_ echo $PATH
/usr/bin /bin /usr/sbin /sbin /usr/local/bin
&gt;_ echo $PATH[1]
/usr/bin
&gt;_ echo $PATH[-1]
/usr/local/bin
</code></pre>
<p>&quot;スライス&quot;を用いてある範囲の要素にアクセスすることもできます.</p>
<pre><code class="language-fish">&gt;_ echo $PATH[1..2]
/usr/bin /bin
&gt;_ echo $PATH[-1..2]
/usr/local/bin /sbin /usr/sbin /bin
</code></pre>
<p>forループを用いてリスト全体(或いはスライス)に繰り返しアクセスすることもできます.</p>
<pre><code class="language-fish">&gt;_ for val in $PATH
     echo &quot;entry: $val&quot;
   end
entry: /usr/bin/
entry: /bin
entry: /usr/sbin
entry: /sbin
entry: /usr/local/bin
</code></pre>
<p>他のリストや文字列と隣り合ったリストは, クオートで囲まなければ直積となります.
([直積], [変数展開] 参照)</p>
<pre><code class="language-fish">&gt;_ set a 1 2 3
&gt;_ set 1 a b c
&gt;_ echo $a$1
1a 2a 3a 1b 2b 3b 1c 2c 3c
&gt;_ echo $a&quot; banana&quot;
1 banana 2 banana 3 banana
&gt;_ echo &quot;$a banana&quot;
1 2 3 banana
</code></pre>
<p>これは[ブレース展開]と似た作用です.</p>
<a class="header" href="#コマンド置換" id="コマンド置換"><h2>コマンド置換</h2></a>
<p>コマンド置換は1つのコマンドの実行結果を他のコマンドの引数として渡す際に使われます.
他のシェルと違って, <code>fish</code>は<code>``</code>ではなく<code>()</code>を用います.</p>
<pre><code class="language-fish">&gt;_ echo In (pwd), running (uname)
In /home/tutorial, running FreeBSD
</code></pre>
<p>コマンドの結果を変数に代入するときによく使われます.</p>
<pre><code class="language-fish">&gt;_ set os (uname)
&gt;_ echo $os
Linux
</code></pre>
<p>コマンド置換はクオートによって展開されません.
その代わり一度クオートを閉じ, コマンド置換を行いそれから再びクオートを開くことによって実現できます.</p>
<pre><code class="language-fish">&gt;_ touch &quot;testing_&quot;(date +%s)&quot;.txt&quot;
&gt;_ ls *.txt
testing_1360099791.txt
</code></pre>
<p>他のシェルと違って, <code>fish</code>は(スペースやタブのような)いかなる空白文字であっても
分割されることはなく, 改行によってのみ分割されます.
これは<code>pkg-config</code>のような複数の引数を1行に出力するコマンドを使う際に問題となります.
スペースでも分割できるようにするためには<code>string split</code>を用いてください.</p>
<pre><code class="language-fish">&gt;_ printf '%s\n' (pkg-config --libs gio-2.0)
-lgio-2.0 -lgobject-2.0 -lglib-2.0
&gt;_ printf '%s\n' (pkg-config --libs gio-2.0 | string split &quot; &quot;)
-lgio-2.0
-lgobject-2.0
-lglib-2.0
</code></pre>
<a class="header" href="#セパレートコマンド" id="セパレートコマンド"><h2>セパレートコマンド(;)</h2></a>
<p>他のシェルと違って, <code>fish</code>は複数のコマンドを独立した行に書くことも同一の行に書くことも許容されます.</p>
<p>ワンライナーで書く場合, <code>;</code>を用います.
以下の2つの例が等価であることを確認してください.</p>
<pre><code class="language-fish">echo fish; echo chips

# or
echo fish
echo chips
</code></pre>
<a class="header" href="#コンバイナand-or-not" id="コンバイナand-or-not"><h2>コンバイナ(and, or, not)</h2></a>
<p><code>fish</code>は馴染みのある<code>&amp;&amp;</code>と<code>||</code>, それから否定の<code>!</code>をサポートしています.</p>
<pre><code class="language-fish">&gt;_ ./configure &amp;&amp; make &amp;&amp; sudo make install
</code></pre>
<p>さらに<code>fish</code>は<code>and</code>, <code>or</code>と<code>not</code>も同様にサポートしています.
最初の2つはコマンドの修飾子で, 優先順位は低くなっています.
以下に例を挙げます.</p>
<pre><code class="language-fish">&gt;_ cp file1.txt file1_bak.txt &amp;&amp; cp file2.txt file2_bak.txt ; and echo &quot;Backup successful&quot;; or echo &quot;Backup failed&quot;
Backup failed
</code></pre>
<p><a href="./separating_commands.html">セパレートコマンド(;)</a>の項で触れたように複数行にわたって
書くこともできます.</p>
<pre><code class="language-fish">cp file1.txt file1_bak.txt &amp;&amp; cp file2.txt file2_bak.txt
and echo &quot;Backup successful&quot;
or echo &quot;Backup failed&quot;
</code></pre>
<a class="header" href="#条件式if-else-switch" id="条件式if-else-switch"><h2>条件式(if, else, switch)</h2></a>
<p><code>if</code>, <code>else if</code>それから<code>else</code>を使うことでコマンドの終了ステータスによって
実行するコードを条件分岐することができます.</p>
<pre><code class="language-fish">if grep fish /etc/shells
    echo Found fish
else if grep bash /etc/shells
    echo Found bash
else
    echo Got nothing
end
</code></pre>
<p>文字列や数字の比較, ファイルのプロパティ(ファイルが存在するか, 書き込み可能かなど)を確認する場合には次のように[<code>test</code>コマンド]を利用してください.</p>
<pre><code class="language-fish">if test &quot;$fish&quot; = &quot;flounder&quot;
    echo FLOUNDER
end

# or

if test &quot;$number&quot; -gt 5
    echo $number is greater than five
else
    echo $number is five or less
end
</code></pre>
<p><a href="./combiners.html">コンバイナ</a>を使うことでさらに複雑な条件式がかけるようになります.</p>
<pre><code class="language-fish">if grep fish /etc/shells; and command -sq fish
    echo fish is installed and configured
end
</code></pre>
<p>もっと複雑になったときには<code>begin</code>と<code>end</code>を使ってグループ化してください.</p>
<p>また, <code>switch</code>コマンドもあります.</p>
<pre><code class="language-fish">switch (uname)
case Linux
    echo Hi Tux!
case Darwin
    echo Hi Hexley!
case FreeBSD NetBSD DragonFly
    echo Hi Beastie!
case '*'
    echo Hi, stranger!
end
</code></pre>
<p><code>case</code>はフォールスルーせず, さらに複数の引数やクオートで囲まれたワイルドカードを受け付けることに注意してください.</p>
<a class="header" href="#関数" id="関数"><h2>関数</h2></a>
<p><code>fish</code>の関数はコマンドのリストであり, オプションとして引数をとることができます.
他のシェルと違って, 引数は<code>$1</code>のような&quot;数字変数&quot;ではなく,<code>$argv</code>という一つのリストとして渡されます.
関数を作るためにビルトインの<code>function</code>コマンドを用います.</p>
<pre><code class="language-fish">&gt;_ function say_hello
     echo Hello $argv
   end
&gt;_ say_hello
Hello
&gt;_ say_hello everybody!
Hello everybody!
</code></pre>
<p>他のシェルと違って, <code>fish</code>はエイリアスや特殊なプロンプト構文を持ちません.
これらも関数で表現します.</p>
<p><code>functions</code>キーワードによって全ての関数名を列挙することができます.
(複数形であることに注意！)
<code>fish</code>にははじめから数多くの関数が定義されています.</p>
<pre><code class="language-fish">&gt;_ functions
alias, cd, delete-or-exit, dirh, dirs, down-or-search, eval, export, fish_command_not_found_setup, fish_config, fish_default_key_bindings, fish_prompt, fish_right_prompt, fish_sigtrap_handler, fish_update_completions, funced, funcsave, grep, help, history, isatty, ls, man, math, nextd, nextd-or-forward-word, open, popd, prevd, prevd-or-backward-word, prompt_pwd, psub, pushd, seq, setenv, trap, type, umask, up-or-search, vared
</code></pre>
<p><code>functions</code>に関数名を渡すことでその関数の中身をみることもできます.</p>
<pre><code class="language-fish">&gt;_ functions ls
function ls --description 'List contents of directory'
    command ls -G $argv
end
</code></pre>
<a class="header" href="#ループ" id="ループ"><h2>ループ</h2></a>
<p>Whileループは次のように使えます.</p>
<pre><code class="language-fish">&gt;_ while true
     echo &quot;Loop forever&quot;
end
Loop forever
Loop forever
Loop forever
...
</code></pre>
<p>Forループはリスト全体を処理することができます.</p>
<pre><code class="language-fish">&gt;_ for file in *.txt
     cp $file $file.bak
   end
</code></pre>
<p><code>seq</code>コマンドを用いることで数列でループすることができます.</p>
<pre><code class="language-fish">&gt;_ for x in (seq 5)
     touch file_$x.txt
   end
</code></pre>
<a class="header" href="#プロンプト" id="プロンプト"><h2>プロンプト</h2></a>
<p>他のシェルと違って, PS1のようなプロンプト変数はありません.
プロンプトを表示するために, <code>fish</code>は<code>fish_prompt</code>という名前の関数を実行し,
その出力がプロンプトとして用いられます.</p>
<p>次のように独自のプロンプトを定義することができます.</p>
<pre><code class="language-fish">&gt;_ function fish_prompt
     echo &quot;New Prompt % &quot;
   end
New Prompt %
</code></pre>
<p>複数行のプロンプトも可能です.
色は<code>set_color</code>コマンドにANSI colorsか16進数のRGB値を渡すことによって設定できます.</p>
<pre><code class="language-fish">&gt;_ function fish_prompt
     set_color purple
     date &quot;+%m/%d/%y&quot;
     set_color FF0
     echo (pwd) '&gt;'
     set_color normal
   end
&lt;span style=&quot;color: purple&quot;&gt;02/06/13&lt;/span&gt;
&lt;span style=&quot;color: #FF0&quot;&gt;/home/tutorial &gt;&lt;/span&gt;___
</code></pre>
<p><code>fish_config_prompt</code>関数を実行することでサンプルの中からプロンプトを選ぶことができます.
また, <code>fish</code>は<code>fish_right_prompt</code>関数によって右プロンプトもサポートしています.</p>
<a class="header" href="#path変数" id="path変数"><h2>PATH変数</h2></a>
<p><code>$PATH</code>は環境変数で, <code>fish</code>がコマンドを探索するディレクトリを保持しています.
他のシェルと違って, <code>$PATH</code>は<a href="./lists.html">リスト</a>であり, コロンで区切られた文字列ではありません.</p>
<p><code>/usr/local/bin</code>と<code>/usr/sbin</code>を<code>$PATH</code>に追加するためには次のように書きます.</p>
<pre><code class="language-fish">&gt;_ set PATH /usr/local/bin /usr/sbin $PATH
</code></pre>
<p><code>$PATH</code>から<code>/usr/local/bin</code>を削除するには次のようにします.</p>
<pre><code class="language-fish">&gt;_ set PATH (string match -v /usr/local/bin $PATH)
</code></pre>
<p>また, 他のシェルの<code>.profile</code>のように<code>config.fish</code>を直接編集しても構いません.</p>
<p>より早い方法として<code>$fish_user_paths</code>という[ユニバーサル変数]を設定すると良いでしょう.
これは自動的に<code>$PATH</code>に追加されます.
例えば,　<code>$PATH</code>に永続的に<code>/usr/local/bin</code>を追加したい場合, 次のようにしてください.</p>
<pre><code class="language-fish">&gt;_ set -U fish_user_paths /usr/local/bin $fish_user_paths
</code></pre>
<p>この方法の利点は設定ファイルを汚さなくてよいところです.
一度コマンドラインで実行さえすれば現在のセッションから永久的にパスが有効になります.
(注意: これを<code>config.fish</code>に書き加えないでください.
もしそうした場合, fishを起動するたびに変数に追加されて長くなっていってしまいます！)</p>
<a class="header" href="#起動に際してbashrc" id="起動に際してbashrc"><h2>起動に際して(.bashrc)</h2></a>
<p><code>fish</code>は<code>~/.config/fish/config.fish</code>に書かれたコマンドを起動時に実行します.
もしこのファイルがなかったら新たに作ることができます.</p>
<p>次のようなコマンドを用いる事で<code>config.fish</code>に直接関数や変数を定義することができます.</p>
<pre><code class="language-fish">&gt;_ cat ~/.config/fish/config.fish

set -x PATH $PATH /sbin/

function ll
    ls -lh $argv
end
</code></pre>
<p>しかし, オートロード関数やユニバーサル変数を使うのが一般的で効果的です.</p>
<a class="header" href="#オートロード関数" id="オートロード関数"><h2>オートロード関数</h2></a>
<p><code>fish</code>がコマンドを認識したとき, <code>~/.config/fish/functions/</code>からそのコマンドを探し,
オートロード関数として呼び出そうとします.</p>
<p>例えば<code>ll</code>という関数が欲しければ, <code>ll.fish</code>というテキストファイルを<code>~/.config/fish/functions/</code>に追加します.</p>
<pre><code class="language-fish">&gt;_ cat ~/.config/fish/functions/ll.fish
function ll
    ls -lh $argv
end
</code></pre>
<p>同様に独自プロンプトを次のように定義するのがより良い方法です.</p>
<pre><code class="language-fish">&gt;_ cat ~/.config/fish/functions/fish_prompt.fish
function fish_prompt
    echo (pwd) &quot;&gt; &quot;
end
</code></pre>
<p>こうしたファイルを自動的に作る方法として[funced], [funcsave]を参考にしてください.</p>
<a class="header" href="#ユニバーサル変数" id="ユニバーサル変数"><h2>ユニバーサル変数</h2></a>
<p>ユニバーサル変数は<code>fish</code>の全てのインスタンスで値が共有される変数で,
現在立ち上げているインスタンスだけでなくリブートした後でさえ継続します.
<code>set -U</code>のオプションを用いることでユニバーサル変数を設定することができます.</p>
<pre><code class="language-fish">&gt;_ set -U EDITOR vim
</code></pre>
<p>上記コマンドを実行した後, 他のインスタンスにも引き継がれます.</p>
<pre><code class="language-fish">&gt;_ echo $EDITOR
vim
</code></pre>
<a class="header" href="#fishをデフォルトシェルにする" id="fishをデフォルトシェルにする"><h2>fishをデフォルトシェルにする</h2></a>
<p><code>fish</code>(或いはその他のシェル)をデフォルトシェルとして使いたい場合,
fishの実行ファイル<code>/usr/local/bin/fish</code>を<code>/etc/shells</code>にも置く必要があります.
それから<code>chsh -s /usr/local/bin/fish</code>でデフォルトシェルに変更することができます.</p>
<p>具体的には次のコマンドに従ってください.</p>
<p>fishを<code>/etc/shells</code>に追加する.</p>
<pre><code class="language-sh">&gt; echo /usr/local/bin/fish | sudo tee -a /etc/shells
</code></pre>
<p>デフォルトシェルをfishに変える.</p>
<pre><code class="language-sh">&gt; chsh -s /usr/local/bin/fish
</code></pre>
<p>(他のシェルに戻すには上記コマンドの引数<code>/usr/local/bin/fish</code>を<code>/bin/bash</code>, <code>/bin/tcsh</code>や<code>/bin/zsh</code>に置き換えてください.)</p>
<a class="header" href="#より多くを知るには" id="より多くを知るには"><h2>より多くを知るには</h2></a>
<p>もっとfishについて知りたければより詳しい[ドキュメント]や
<a href="https://lists.sourceforge.net/lists/listinfo/fish-users">公式メーリングリスト</a>,
<code>irc.oftc.net</code>のIRCチャンネル#fish,
<a href="https://github.com/fish-shell/fish-shell/">github page</a>を参照してください.</p>
<a class="header" href="#なぜfishなのか-1" id="なぜfishなのか-1"><h2>なぜfishなのか？</h2></a>
<p><code>fish</code>はbashやzshのように完備で, 気の利いたユーザーフレンドリーなコマンドラインシェルです.
<code>fish</code>はシンタックスハイライト, オートサジェスト, タブ補完といった強力な機能を学習したり
設定をいじったりすることなく利用することができます.</p>
<p>コマンドラインを難しい構文を覚えたり設定ファイルを書いたりすることなくもっと生産的に, 便利に, 楽しくしたいなら<code>fish</code>こそが探し求めていたものになるでしょう！</p>
<a class="header" href="#はじめかた-1" id="はじめかた-1"><h2>はじめかた</h2></a>
<p>一度インストールしてしまえば今使っているシェルで<code>fish</code>とタイプするだけで試してみることができます！</p>
<p>起動するとfishのプロンプトが表示されます.
これはもう準備ができていてfishを始めることができることを意味しています.</p>
<pre><code class="language-fish">&gt; fish
Welcome to fish, the friendly interactive shell
Type help for instructions on how to use fish
you@hostname ~&gt;____
</code></pre>
<p>このプロンプトは<code>fish</code>のデフォルトのプロンプトで, あなたのユーザーネーム, ホストネーム,
それからワーキングディレクトリを表示しています.</p>
<ul>
<li>プロンプトを変えるためには[プロンプトの変えかた]</li>
<li>fishをログインシェルにするには[デフォルトシェルをfishに変える]</li>
</ul>
<p>を読んでください.</p>
<p>以降, プロンプトは簡単のため'<code>&gt;_</code>'で表します.</p>
<a class="header" href="#fishを学ぶ-1" id="fishを学ぶ-1"><h2>fishを学ぶ</h2></a>
<p>このチュートリアルではコマンドラインシェルとUnixコマンドの基本的な理解と, fishが動く環境を前提としています.</p>
<p>もし他のシェルのことをよく知っていて, <code>fish</code>がそれとどう異なるのかを知りたい場合は<em>他のシェルと違って</em>というフレーズを検索してください.
これは重要な違いを示す時に使われています.</p>
<a class="header" href="#コマンドの実行-1" id="コマンドの実行-1"><h2>コマンドの実行</h2></a>
<p><code>fish</code>は他のシェルと同じように, コマンドに続けて引数を与えることで実行します.
スペースはセパレータとなっています.</p>
<pre><code class="language-fish">&gt;_ echo hello world
hello world
</code></pre>
<p>空白文字として引数を与えたい場合, バックスラッシュを前置するか或いはシングルクオート,
ダブルクオートで囲むことによって実現します.</p>
<pre><code class="language-fish">&gt;_ mkdir My\ Files
&gt;_ cp ~/Some\ File 'My Files'
&gt;_ ls &quot;My Files&quot;
Some File
</code></pre>
<p>コマンドはセミコロンを用いることによって繋げることができます.</p>
<a class="header" href="#ヘルプを読む-1" id="ヘルプを読む-1"><h2>ヘルプを読む</h2></a>
<p><code>fish</code>には素晴らしいhelpとmanページが備わっています.
<code>help</code>コマンドを実行するとウェブブラウザでヘルプを開き, <code>man</code>コマンドはターミナル上でmanページを開きます.
特定のコマンドについてのヘルプを読むこともでき, 例えば<code>help set</code>とすればウェブブラウザで,
<code>mans set</code>とすればターミナルで読むことができます.</p>
<pre><code class="language-fish">&gt;_ man set
set - handle shell variables
  Synopsis...
</code></pre>
<a class="header" href="#シンタックスハイライト-1" id="シンタックスハイライト-1"><h2>シンタックスハイライト</h2></a>
<p><code>fish</code>を使っているとタイプするに従ってシンタックスハイライトが効いていることに
すぐに気がつくでしょう.
無効なコマンドはデフォルトでは赤く表示されます.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;/bin/mkd&lt;/eror&gt;
</code></pre>
<p>コマンドが存在しない或いは実行可能でない場合に無効となり, 有効になると色が変化します.</p>
<pre><code class="language-fish">&gt;_ /bin/mkdir
</code></pre>
<p><code>fish</code>はファイルパスが有効なとき下線を示すでしょう.</p>
<pre><code class="language-fish">&gt;_ cat &lt;u&gt;~/somefi&lt;/u&gt;___
</code></pre>
<p>これは'<code>somefi</code>'から始まるファイルが存在していることを示していて, タイピングの補助となります.</p>
<p>これらのシンタックスハイライトは他にもたくさんありますが, <code>fish_config</code>を変更したり
変数を直接編集することによって色を変えることができます.</p>
<a class="header" href="#ワイルドカード-1" id="ワイルドカード-1"><h2>ワイルドカード</h2></a>
<p><code>fish</code>はワイルドカードの<code>*</code>をサポートしています.
全てのJPEGファイルをリストアップするには次のようにします.</p>
<pre><code class="language-fish">&gt;_ ls *.jpg
lena.jpg
meena.jpg
santa maria.jpg
</code></pre>
<p>複数のワイルドカードを用いることもできます.</p>
<pre><code class="language-fish">&gt;_ ls l*.p*
lena.png
lesson.pdf
</code></pre>
<p>特に強力なのはディレクトリを再帰的に探索する<code>**</code>です.</p>
<pre><code class="language-fish">&gt;_ ls /var/**.log
/var/log/system.log
/var/run/sntp.log
</code></pre>
<p>ディレクトリの探査に時間がかかるときは<code>Ctrl-c</code>で中止することができます.</p>
<a class="header" href="#パイプとリダイレクト-1" id="パイプとリダイレクト-1"><h2>パイプとリダイレクト</h2></a>
<p><code>|</code>を用いることでコマンドをパイプすることができます.</p>
<pre><code class="language-fish">&gt;_ echo hello world | wc
       1       2      12
</code></pre>
<p>stdinとstdoutは馴染み深い<code>&lt;</code>と<code>&gt;</code>によってリダイレクトすることができます.
stderrは<code>2&gt;</code>によってリダイレクトされます.</p>
<pre><code class="language-fish">&gt;_ grep fish &lt; /etc/shells &gt; ~/output.txt 2&gt; ~/errors.txt
</code></pre>
<a class="header" href="#オートサジェスト-1" id="オートサジェスト-1"><h2>オートサジェスト</h2></a>
<p><code>fish</code>はタイプに従ってコマンドをサジェストします.
サジェストされた結果はカーソルの右側に灰色で示されます.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;/bin/h&lt;/eror&gt;&lt;s&gt;___ostname&lt;/s&gt;
</code></pre>
<p>パスやオプションをサジェストすることもできます.</p>
<pre><code class="language-fish">&gt;_ grep --i&lt;s&gt;___gnore-case&lt;/s&gt;
</code></pre>
<p>もちろん履歴にもはたらきます. 一度コマンドを実行したことがあれば, 数文字タイプしただけで再度
実行することができます.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;r&lt;&lt;/eror&gt;&lt;s&gt;___sync -avze ssh . myname@somelonghost.com:/some/long/path/doo/dee/doo/dee/doo&lt;/s&gt;
</code></pre>
<p>サジェストの結果を利用するには<code>→</code>または<code>Ctrl-f</code>を押してください.
最初の1語だけを利用したい場合は<code>Alt-→</code>を押してください.
また, サジェストが求めているものと異なればそのまま無視して構いません.</p>
<a class="header" href="#タブ補完-1" id="タブ補完-1"><h2>タブ補完</h2></a>
<p><code>fish</code>はすぐに使えるリッチなタブ補完を備えています.
<code>tab</code>を押してみると, <code>fish</code>はコマンドや引数, パスを補完しようとするでしょう.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;/pri&lt;/eror&gt; :kbd:`Tab` =&gt; /private
</code></pre>
<p>複数の候補が見つかれば, それらをリストとして表示します.</p>
<pre><code class="language-fish">&gt;_ &lt;eror&gt;~/stuff/s&lt;/eror&gt; :kbd:`Tab`
&lt;mtch&gt;~/stuff/script.sh  &lt;i&gt;(Executable, 4.8kB)&lt;/i&gt;  \mtch{~/stuff/s&lt;/mtch&gt;ources/  &lt;i&gt;(Directory)&lt;/i&gt;}
</code></pre>
<p><code>tab</code>を押すたびにその候補を順にフォーカスします.</p>
<p><code>fish</code>はgitのブランチのようなものまでも補完することができます.</p>
<pre><code class="language-fish">&gt;_ git merge pr :kbd:`Tab` =&gt; git merge prompt_designer
&gt;_ git checkout b :kbd:`Tab`
&lt;mtch&gt;builtin_list_io_merge &lt;i&gt;(Branch)&lt;/i&gt; \mtch{b&lt;/mtch&gt;uiltin_set_color &lt;i&gt;(Branch)&lt;/i&gt; &lt;mtch&gt;b&lt;/mtch&gt;usted_events &lt;i&gt;(Tag)&lt;/i&gt;}
</code></pre>
<p>実際に<code>tab</code>を押して確認してみましょう！</p>
<a class="header" href="#変数-1" id="変数-1"><h2>変数</h2></a>
<p>他のシェルと同じように, <code>$</code>によって変数を扱います.</p>
<pre><code class="language-fish">&gt;_ echo My home directory is $HOME
My home directory is /home/tutorial
</code></pre>
<p>変数はダブルクオートのなかでは置換されますが, シングルクオートの中では置換されません.</p>
<pre><code class="language-fish">&gt;_ echo &quot;My current directory is $PWD&quot;
My current directory is /home/tutorial
&gt;_ echo 'My current directory is $PWD'
My current directory is $PWD
</code></pre>
<p>他のシェルと違って, <code>fish</code>は変数を代入する構文を持ちません.
代わりに変数名とその値を引数にとる, <code>set</code>コマンドを持ちます.</p>
<pre><code class="language-fish">&gt;_ set name 'Mister Noodle'
&gt;_ echo $name
Mister Noodle
</code></pre>
<p>(クオートに注意してください. もしこれがなければ<code>Mister</code>と<code>Noodle</code>は別々の引数として認識され, <code>$name</code>は2つの要素を持つリストになります.)</p>
<p>他のシェルと違って, 変数は置換後に分割されることはありません.</p>
<pre><code class="language-fish">&gt;_ mkdir $name
&gt;_ ls
Mister Noodle
</code></pre>
<p>bashでは上記コマンドで&quot;Mister&quot;と&quot;Noodle&quot;という2つのディレクトリが作られます.
<code>fish</code>では&quot;Mister Noodle&quot;という値を持った変数によって1つのディレクトリが作られます.
つまり<code>mkdir</code>にはスペースを含んだ文字列の引数として渡されます.
他のシェルではリストという表現ではなく&quot;配列&quot;という用語が用いられます.</p>
<a class="header" href="#終了ステータス-1" id="終了ステータス-1"><h2>終了ステータス</h2></a>
<p>他のシェルと違って, <code>fish</code>は直前に実行したコマンドの終了ステータスを<code>$?</code>ではなく<code>$status</code>という変数に格納します.</p>
<pre><code class="language-fish">&gt;_ false
&gt;_ echo $status
1
</code></pre>
<p>0は成功, それ以外はエラーを表します.
<code>$pipestatus</code>というパイプの過程の終了ステータスを格納する配列の変数もあります.</p>
<a class="header" href="#エクスポートシェル変数-1" id="エクスポートシェル変数-1"><h2>エクスポート(シェル変数)</h2></a>
<p>他のシェルと違って, <code>fish</code>は<code>export</code>コマンドをサポートしていません.
代わりに<code>set</code>コマンドの<code>--export</code>或いは<code>-x</code>オプションによって変数をエクスポートします.</p>
<pre><code class="language-fish">&gt;_ set -x MyVariable SomeValue
&gt;_ env | grep MyVariable
MyVariable=SomeValue
</code></pre>
<p>変数は<code>-e</code>若しくは<code>--erase</code>オプションによって削除することができます.</p>
<pre><code class="language-fish">&gt;_ set -e MyVariable
&gt;_ env | grep MyVariable
(no output)
</code></pre>
<a class="header" href="#リスト-1" id="リスト-1"><h2>リスト</h2></a>
<p>先に見た<code>set</code>コマンドはクオートで囲むことによって<code>Mister Noodle</code>を1つの引数として扱いました.
もし2つの引数だったなら, 変数<code>name</code>は長さ2のリストになります.
実際, <code>fish</code>の全ての変数はリストであり, いくつでも値を保持できるし全く持たないことも可能です.</p>
<p><code>$PWD</code>のようないくつかの変数は1つしか値を持ちません.
慣習に従って変数の値というとき, 最初(かつただ1つ)の値を指すことにします.</p>
<p><code>$PATH</code>のようなその他の変数は複数の値を保持しています.
これらの変数は複数の引数として展開されます.</p>
<pre><code class="language-fish">&gt;_ echo $PATH
/usr/bin /bin /usr/sbin /sbin /usr/local/bin
</code></pre>
<p>&quot;PATH&quot;で終わる変数は自動的にコロンで分割されてリストになります.
これらはサブコマンドに渡されるときにコロンによって結合されます.
この仕様は<code>$PATH</code>はコロンで区切られていると想定している他のツールとの互換性のためにあります.
明示的にパスを変数に加えるには<code>set --path</code>, 削除するには<code>set --unpath</code>を用いることができます.</p>
<p>リストは要素として他のリストを保持することはできず, 再帰的ではありません.
変数は文字列のリストであり, 他にはありえません</p>
<p>リストの要素数を得るには<code>count</code>コマンドを使います.</p>
<pre><code class="language-fish">&gt;_ count $PATH
5
</code></pre>
<p>リスト自身に追加の引数をセットすることで, 要素を追加することができます.
<code>$PATH</code>に<code>/usr/local/bin</code>を追加する例を示します.</p>
<pre><code class="language-fish">&gt;_ set PATH $PATH /usr/local/bin
</code></pre>
<p><code>[]</code>を用いることで個別の要素にアクセスすることができます.
インデックスは1から始まり, 最後は-1です.</p>
<pre><code class="language-fish">&gt;_ echo $PATH
/usr/bin /bin /usr/sbin /sbin /usr/local/bin
&gt;_ echo $PATH[1]
/usr/bin
&gt;_ echo $PATH[-1]
/usr/local/bin
</code></pre>
<p>&quot;スライス&quot;を用いてある範囲の要素にアクセスすることもできます.</p>
<pre><code class="language-fish">&gt;_ echo $PATH[1..2]
/usr/bin /bin
&gt;_ echo $PATH[-1..2]
/usr/local/bin /sbin /usr/sbin /bin
</code></pre>
<p>forループを用いてリスト全体(或いはスライス)に繰り返しアクセスすることもできます.</p>
<pre><code class="language-fish">&gt;_ for val in $PATH
     echo &quot;entry: $val&quot;
   end
entry: /usr/bin/
entry: /bin
entry: /usr/sbin
entry: /sbin
entry: /usr/local/bin
</code></pre>
<p>他のリストや文字列と隣り合ったリストは, クオートで囲まなければ直積となります.
([直積], [変数展開] 参照)</p>
<pre><code class="language-fish">&gt;_ set a 1 2 3
&gt;_ set 1 a b c
&gt;_ echo $a$1
1a 2a 3a 1b 2b 3b 1c 2c 3c
&gt;_ echo $a&quot; banana&quot;
1 banana 2 banana 3 banana
&gt;_ echo &quot;$a banana&quot;
1 2 3 banana
</code></pre>
<p>これは[ブレース展開]と似た作用です.</p>
<a class="header" href="#コマンド置換-1" id="コマンド置換-1"><h2>コマンド置換</h2></a>
<p>コマンド置換は1つのコマンドの実行結果を他のコマンドの引数として渡す際に使われます.
他のシェルと違って, <code>fish</code>は<code>``</code>ではなく<code>()</code>を用います.</p>
<pre><code class="language-fish">&gt;_ echo In (pwd), running (uname)
In /home/tutorial, running FreeBSD
</code></pre>
<p>コマンドの結果を変数に代入するときによく使われます.</p>
<pre><code class="language-fish">&gt;_ set os (uname)
&gt;_ echo $os
Linux
</code></pre>
<p>コマンド置換はクオートによって展開されません.
その代わり一度クオートを閉じ, コマンド置換を行いそれから再びクオートを開くことによって実現できます.</p>
<pre><code class="language-fish">&gt;_ touch &quot;testing_&quot;(date +%s)&quot;.txt&quot;
&gt;_ ls *.txt
testing_1360099791.txt
</code></pre>
<p>他のシェルと違って, <code>fish</code>は(スペースやタブのような)いかなる空白文字であっても
分割されることはなく, 改行によってのみ分割されます.
これは<code>pkg-config</code>のような複数の引数を1行に出力するコマンドを使う際に問題となります.
スペースでも分割できるようにするためには<code>string split</code>を用いてください.</p>
<pre><code class="language-fish">&gt;_ printf '%s\n' (pkg-config --libs gio-2.0)
-lgio-2.0 -lgobject-2.0 -lglib-2.0
&gt;_ printf '%s\n' (pkg-config --libs gio-2.0 | string split &quot; &quot;)
-lgio-2.0
-lgobject-2.0
-lglib-2.0
</code></pre>
<a class="header" href="#セパレートコマンド-1" id="セパレートコマンド-1"><h2>セパレートコマンド(;)</h2></a>
<p>他のシェルと違って, <code>fish</code>は複数のコマンドを独立した行に書くことも同一の行に書くことも許容されます.</p>
<p>ワンライナーで書く場合, <code>;</code>を用います.
以下の2つの例が等価であることを確認してください.</p>
<pre><code class="language-fish">echo fish; echo chips

# or
echo fish
echo chips
</code></pre>
<a class="header" href="#コンバイナand-or-not-1" id="コンバイナand-or-not-1"><h2>コンバイナ(and, or, not)</h2></a>
<p><code>fish</code>は馴染みのある<code>&amp;&amp;</code>と<code>||</code>, それから否定の<code>!</code>をサポートしています.</p>
<pre><code class="language-fish">&gt;_ ./configure &amp;&amp; make &amp;&amp; sudo make install
</code></pre>
<p>さらに<code>fish</code>は<code>and</code>, <code>or</code>と<code>not</code>も同様にサポートしています.
最初の2つはコマンドの修飾子で, 優先順位は低くなっています.
以下に例を挙げます.</p>
<pre><code class="language-fish">&gt;_ cp file1.txt file1_bak.txt &amp;&amp; cp file2.txt file2_bak.txt ; and echo &quot;Backup successful&quot;; or echo &quot;Backup failed&quot;
Backup failed
</code></pre>
<p><a href="tutorial/./separating_commands.html">セパレートコマンド(;)</a>の項で触れたように複数行にわたって
書くこともできます.</p>
<pre><code class="language-fish">cp file1.txt file1_bak.txt &amp;&amp; cp file2.txt file2_bak.txt
and echo &quot;Backup successful&quot;
or echo &quot;Backup failed&quot;
</code></pre>
<a class="header" href="#条件式if-else-switch-1" id="条件式if-else-switch-1"><h2>条件式(if, else, switch)</h2></a>
<p><code>if</code>, <code>else if</code>それから<code>else</code>を使うことでコマンドの終了ステータスによって
実行するコードを条件分岐することができます.</p>
<pre><code class="language-fish">if grep fish /etc/shells
    echo Found fish
else if grep bash /etc/shells
    echo Found bash
else
    echo Got nothing
end
</code></pre>
<p>文字列や数字の比較, ファイルのプロパティ(ファイルが存在するか, 書き込み可能かなど)を確認する場合には次のように[<code>test</code>コマンド]を利用してください.</p>
<pre><code class="language-fish">if test &quot;$fish&quot; = &quot;flounder&quot;
    echo FLOUNDER
end

# or

if test &quot;$number&quot; -gt 5
    echo $number is greater than five
else
    echo $number is five or less
end
</code></pre>
<p><a href="tutorial/./combiners.html">コンバイナ</a>を使うことでさらに複雑な条件式がかけるようになります.</p>
<pre><code class="language-fish">if grep fish /etc/shells; and command -sq fish
    echo fish is installed and configured
end
</code></pre>
<p>もっと複雑になったときには<code>begin</code>と<code>end</code>を使ってグループ化してください.</p>
<p>また, <code>switch</code>コマンドもあります.</p>
<pre><code class="language-fish">switch (uname)
case Linux
    echo Hi Tux!
case Darwin
    echo Hi Hexley!
case FreeBSD NetBSD DragonFly
    echo Hi Beastie!
case '*'
    echo Hi, stranger!
end
</code></pre>
<p><code>case</code>はフォールスルーせず, さらに複数の引数やクオートで囲まれたワイルドカードを受け付けることに注意してください.</p>
<a class="header" href="#関数-1" id="関数-1"><h2>関数</h2></a>
<p><code>fish</code>の関数はコマンドのリストであり, オプションとして引数をとることができます.
他のシェルと違って, 引数は<code>$1</code>のような&quot;数字変数&quot;ではなく,<code>$argv</code>という一つのリストとして渡されます.
関数を作るためにビルトインの<code>function</code>コマンドを用います.</p>
<pre><code class="language-fish">&gt;_ function say_hello
     echo Hello $argv
   end
&gt;_ say_hello
Hello
&gt;_ say_hello everybody!
Hello everybody!
</code></pre>
<p>他のシェルと違って, <code>fish</code>はエイリアスや特殊なプロンプト構文を持ちません.
これらも関数で表現します.</p>
<p><code>functions</code>キーワードによって全ての関数名を列挙することができます.
(複数形であることに注意！)
<code>fish</code>にははじめから数多くの関数が定義されています.</p>
<pre><code class="language-fish">&gt;_ functions
alias, cd, delete-or-exit, dirh, dirs, down-or-search, eval, export, fish_command_not_found_setup, fish_config, fish_default_key_bindings, fish_prompt, fish_right_prompt, fish_sigtrap_handler, fish_update_completions, funced, funcsave, grep, help, history, isatty, ls, man, math, nextd, nextd-or-forward-word, open, popd, prevd, prevd-or-backward-word, prompt_pwd, psub, pushd, seq, setenv, trap, type, umask, up-or-search, vared
</code></pre>
<p><code>functions</code>に関数名を渡すことでその関数の中身をみることもできます.</p>
<pre><code class="language-fish">&gt;_ functions ls
function ls --description 'List contents of directory'
    command ls -G $argv
end
</code></pre>
<a class="header" href="#ループ-1" id="ループ-1"><h2>ループ</h2></a>
<p>Whileループは次のように使えます.</p>
<pre><code class="language-fish">&gt;_ while true
     echo &quot;Loop forever&quot;
end
Loop forever
Loop forever
Loop forever
...
</code></pre>
<p>Forループはリスト全体を処理することができます.</p>
<pre><code class="language-fish">&gt;_ for file in *.txt
     cp $file $file.bak
   end
</code></pre>
<p><code>seq</code>コマンドを用いることで数列でループすることができます.</p>
<pre><code class="language-fish">&gt;_ for x in (seq 5)
     touch file_$x.txt
   end
</code></pre>
<a class="header" href="#プロンプト-1" id="プロンプト-1"><h2>プロンプト</h2></a>
<p>他のシェルと違って, PS1のようなプロンプト変数はありません.
プロンプトを表示するために, <code>fish</code>は<code>fish_prompt</code>という名前の関数を実行し,
その出力がプロンプトとして用いられます.</p>
<p>次のように独自のプロンプトを定義することができます.</p>
<pre><code class="language-fish">&gt;_ function fish_prompt
     echo &quot;New Prompt % &quot;
   end
New Prompt %
</code></pre>
<p>複数行のプロンプトも可能です.
色は<code>set_color</code>コマンドにANSI colorsか16進数のRGB値を渡すことによって設定できます.</p>
<pre><code class="language-fish">&gt;_ function fish_prompt
     set_color purple
     date &quot;+%m/%d/%y&quot;
     set_color FF0
     echo (pwd) '&gt;'
     set_color normal
   end
&lt;span style=&quot;color: purple&quot;&gt;02/06/13&lt;/span&gt;
&lt;span style=&quot;color: #FF0&quot;&gt;/home/tutorial &gt;&lt;/span&gt;___
</code></pre>
<p><code>fish_config_prompt</code>関数を実行することでサンプルの中からプロンプトを選ぶことができます.
また, <code>fish</code>は<code>fish_right_prompt</code>関数によって右プロンプトもサポートしています.</p>
<a class="header" href="#path変数-1" id="path変数-1"><h2>PATH変数</h2></a>
<p><code>$PATH</code>は環境変数で, <code>fish</code>がコマンドを探索するディレクトリを保持しています.
他のシェルと違って, <code>$PATH</code>は<a href="tutorial/./lists.html">リスト</a>であり, コロンで区切られた文字列ではありません.</p>
<p><code>/usr/local/bin</code>と<code>/usr/sbin</code>を<code>$PATH</code>に追加するためには次のように書きます.</p>
<pre><code class="language-fish">&gt;_ set PATH /usr/local/bin /usr/sbin $PATH
</code></pre>
<p><code>$PATH</code>から<code>/usr/local/bin</code>を削除するには次のようにします.</p>
<pre><code class="language-fish">&gt;_ set PATH (string match -v /usr/local/bin $PATH)
</code></pre>
<p>また, 他のシェルの<code>.profile</code>のように<code>config.fish</code>を直接編集しても構いません.</p>
<p>より早い方法として<code>$fish_user_paths</code>という[ユニバーサル変数]を設定すると良いでしょう.
これは自動的に<code>$PATH</code>に追加されます.
例えば,　<code>$PATH</code>に永続的に<code>/usr/local/bin</code>を追加したい場合, 次のようにしてください.</p>
<pre><code class="language-fish">&gt;_ set -U fish_user_paths /usr/local/bin $fish_user_paths
</code></pre>
<p>この方法の利点は設定ファイルを汚さなくてよいところです.
一度コマンドラインで実行さえすれば現在のセッションから永久的にパスが有効になります.
(注意: これを<code>config.fish</code>に書き加えないでください.
もしそうした場合, fishを起動するたびに変数に追加されて長くなっていってしまいます！)</p>
<a class="header" href="#起動に際してbashrc-1" id="起動に際してbashrc-1"><h2>起動に際して(.bashrc)</h2></a>
<p><code>fish</code>は<code>~/.config/fish/config.fish</code>に書かれたコマンドを起動時に実行します.
もしこのファイルがなかったら新たに作ることができます.</p>
<p>次のようなコマンドを用いる事で<code>config.fish</code>に直接関数や変数を定義することができます.</p>
<pre><code class="language-fish">&gt;_ cat ~/.config/fish/config.fish

set -x PATH $PATH /sbin/

function ll
    ls -lh $argv
end
</code></pre>
<p>しかし, オートロード関数やユニバーサル変数を使うのが一般的で効果的です.</p>
<a class="header" href="#オートロード関数-1" id="オートロード関数-1"><h2>オートロード関数</h2></a>
<p><code>fish</code>がコマンドを認識したとき, <code>~/.config/fish/functions/</code>からそのコマンドを探し,
オートロード関数として呼び出そうとします.</p>
<p>例えば<code>ll</code>という関数が欲しければ, <code>ll.fish</code>というテキストファイルを<code>~/.config/fish/functions/</code>に追加します.</p>
<pre><code class="language-fish">&gt;_ cat ~/.config/fish/functions/ll.fish
function ll
    ls -lh $argv
end
</code></pre>
<p>同様に独自プロンプトを次のように定義するのがより良い方法です.</p>
<pre><code class="language-fish">&gt;_ cat ~/.config/fish/functions/fish_prompt.fish
function fish_prompt
    echo (pwd) &quot;&gt; &quot;
end
</code></pre>
<p>こうしたファイルを自動的に作る方法として[funced], [funcsave]を参考にしてください.</p>
<a class="header" href="#ユニバーサル変数-1" id="ユニバーサル変数-1"><h2>ユニバーサル変数</h2></a>
<p>ユニバーサル変数は<code>fish</code>の全てのインスタンスで値が共有される変数で,
現在立ち上げているインスタンスだけでなくリブートした後でさえ継続します.
<code>set -U</code>のオプションを用いることでユニバーサル変数を設定することができます.</p>
<pre><code class="language-fish">&gt;_ set -U EDITOR vim
</code></pre>
<p>上記コマンドを実行した後, 他のインスタンスにも引き継がれます.</p>
<pre><code class="language-fish">&gt;_ echo $EDITOR
vim
</code></pre>
<a class="header" href="#fishをデフォルトシェルにする-1" id="fishをデフォルトシェルにする-1"><h2>fishをデフォルトシェルにする</h2></a>
<p><code>fish</code>(或いはその他のシェル)をデフォルトシェルとして使いたい場合,
fishの実行ファイル<code>/usr/local/bin/fish</code>を<code>/etc/shells</code>にも置く必要があります.
それから<code>chsh -s /usr/local/bin/fish</code>でデフォルトシェルに変更することができます.</p>
<p>具体的には次のコマンドに従ってください.</p>
<p>fishを<code>/etc/shells</code>に追加する.</p>
<pre><code class="language-sh">&gt; echo /usr/local/bin/fish | sudo tee -a /etc/shells
</code></pre>
<p>デフォルトシェルをfishに変える.</p>
<pre><code class="language-sh">&gt; chsh -s /usr/local/bin/fish
</code></pre>
<p>(他のシェルに戻すには上記コマンドの引数<code>/usr/local/bin/fish</code>を<code>/bin/bash</code>, <code>/bin/tcsh</code>や<code>/bin/zsh</code>に置き換えてください.)</p>
<a class="header" href="#より多くを知るには-1" id="より多くを知るには-1"><h2>より多くを知るには</h2></a>
<p>もっとfishについて知りたければより詳しい[ドキュメント]や
<a href="https://lists.sourceforge.net/lists/listinfo/fish-users">公式メーリングリスト</a>,
<code>irc.oftc.net</code>のIRCチャンネル#fish,
<a href="https://github.com/fish-shell/fish-shell/">github page</a>を参照してください.</p>
<a class="header" href="#よくある質問" id="よくある質問"><h1>よくある質問</h1></a>
<a class="header" href="#環境変数の追加-削除をするには" id="環境変数の追加-削除をするには"><h2>環境変数の追加, 削除をするには？</h2></a>
<p>[set]コマンドを使ってください.</p>
<pre><code class="language-fish">set -x key value
set -e key
</code></pre>
<a class="header" href="#ログイン時にコマンドを実行するには-fishのbashrcは" id="ログイン時にコマンドを実行するには-fishのbashrcは"><h2>ログイン時にコマンドを実行するには？ fishの.bashrcは？</h2></a>
<p><code>~/.config/fish/config.fish</code>を編集してください.
もし存在しなければ作成することもできます.</p>
<a class="header" href="#独自のプロンプトを設定するには" id="独自のプロンプトを設定するには"><h2>独自のプロンプトを設定するには？</h2></a>
<p>プロンプトは<code>fish_prompt</code>関数の出力になります.
この関数は<code>~/.config/fish/functions/fish_prompt.fish</code>に配置してください.
簡単な例を下に示します.</p>
<pre><code class="language-fish">function fish_prompt
    set_color $fish_color_cwd
    echo -n (prompt_pwd)
    set_color normal
    echo -n ' &gt; '
end
</code></pre>
<p>Web上の設定ツール, [fish_config]を使うこともできます.
プロンプトのサンプルから選んで試すことができます.</p>
<a class="header" href="#履歴からコマンドを実行するには" id="履歴からコマンドを実行するには"><h2>履歴からコマンドを実行するには？</h2></a>
<p>コマンドの一部を入力し, それから<code>↑</code>(up)或いは<code>↓</code>(down)を押してください.
マッチした履歴を選択することができます.</p>
<a class="header" href="#サブコマンドを実行するには-バッククオートが動作しません" id="サブコマンドを実行するには-バッククオートが動作しません"><h2>サブコマンドを実行するには？ バッククオートが動作しません！</h2></a>
<p><code>fish</code>はサブコマンドを実行するために<code>()</code>を使います.</p>
<pre><code class="language-fish">for i in (ls)
    echo $i
end
</code></pre>
<a class="header" href="#pkg-configのような出力が1行の長い文字列のときどうしたらいい" id="pkg-configのような出力が1行の長い文字列のときどうしたらいい"><h2>pkg-configのような出力が1行の長い文字列のときどうしたらいい？</h2></a>
<p>他のシェルと違って, <code>fish</code>は改行時のみ置換されたコマンドを分割します.
スペースやタブ, $IFSに含まれる文字では分割されません.</p>
<p>これは次のことを意味します.</p>
<pre><code class="language-fish">echo x(printf '%s ' a b c)x
</code></pre>
<p>を実行すると<code>xa b c x</code>が出力されます.
しかし次の場合,</p>
<pre><code class="language-fish">echo x(printf '%s\n' a b c)x
</code></pre>
<p><code>xax xbx xcx</code>が出力されます.</p>
<p>ほぼ全てのケースにおいてスペース区切りは望ましくないので, この仕様は改善点であるといえます.</p>
<p>しかしながら, <code>pkg-config</code>やその周辺ツールなどではスペース区切りが必要となっています.
このような場合, <code>string split &quot; &quot;</code>を使ってください.</p>
<pre><code class="language-fish">g++ example_01.cpp (pkg-config --cflags --libs gtk+-2.0 | string split &quot; &quot;)
</code></pre>
<a class="header" href="#コマンドの終了ステータスを得るには" id="コマンドの終了ステータスを得るには"><h2>コマンドの終了ステータスを得るには？</h2></a>
<p><code>$status</code>変数を使ってください.
これは他のシェルで使われている<code>$?</code>変数を置き換えるものです.</p>
<pre><code class="language-fish">somecommand
if test $status -eq 7
    echo &quot;That's my lucky number!&quot;
end
</code></pre>
<p>もし単に成功か失敗かを知りたいだけなら, <code>if</code>のような条件構文に直接渡してください.</p>
<pre><code class="language-fish">if somecommand
    echo &quot;Command succeeded&quot;
else
    echo &quot;Command failed&quot;
end
</code></pre>
<p>より詳しくは[test]コマンドや[if]コマンドを参照してください.</p>
<a class="header" href="#一回限りの環境変数を設定するには" id="一回限りの環境変数を設定するには"><h2>一回限りの環境変数を設定するには？</h2></a>
<p><code>SOME_VAR=1 command</code>というコマンドは次のエラーを引き起こします.
<code>Unknown command &quot;SOME_VAR=1&quot;</code></p>
<p>このようなときには<code>env</code>コマンドを使ってください.</p>
<p><code>env SOME_VAR=1 command</code></p>
<p>ブロック中で次のようにローカル変数を宣言することもできます.</p>
<pre><code class="language-fish">begin
    set -lx SOME_VAR 1
    command
end
</code></pre>
<a class="header" href="#変数が定義されるているか確認するには" id="変数が定義されるているか確認するには"><h2>変数が定義されるているか確認するには？</h2></a>
<p><code>set -q var</code>コマンドを使ってください.</p>
<p>例えば<code>if set -q --$var; echo variable defined; end</code>のように使います;</p>
<p>複数の変数を確認するには'<code>and</code>や<code>or</code>の演算子を使ってください.</p>
<pre><code class="language-fish">if set -q var1; or set -q var2
    echo either variable defined
end
</code></pre>
<p>定義済みの変数は空である可能性もあることに注意してください.
次の2つのコマンドで空の変数を定義できます.
<code>set var</code> <code>set var &quot;&quot;</code></p>
<a class="header" href="#変数が空でないか確認するには" id="変数が空でないか確認するには"><h2>変数が空でないか確認するには？</h2></a>
<p><code>string length -q -- $var</code>を使ってください.
例えば<code>if string length -q -- $var; echo not empty; end</code>のように使います.</p>
<p><code>string length</code>は複数の引数のリストを個別にチェックし, 1つでも空でなければ0を返します.</p>
<pre><code class="language-fish">if string length -q -- $var1 $var2 $var3
    echo at least one of these variables is not empty
end
</code></pre>
<p>代わりに<code>test -n &quot;$var&quot;</code>を使ってください.
ただしダブルクオートで変数を括ることを忘れないでください.
例えば<code>if test -n &quot;$var&quot;; echo not empty; end</code>のように使います.
<code>test</code>コマンドはオプションとして<code>-a</code>(and)と<code>-o</code>(or)を持ちます.</p>
<pre><code class="language-fish">if test -n &quot;$var1&quot; -o -n &quot;$var2&quot; -o -n &quot;$var3&quot;
    echo at least one of these variables is not empty
end
</code></pre>
<a class="header" href="#set--uxユニバーサル変数のエクスポートが働かない" id="set--uxユニバーサル変数のエクスポートが働かない"><h2>set -Ux(ユニバーサル変数のエクスポート)が働かない？</h2></a>
<p>既に同じ名前のグローバル変数が設定されています.</p>
<p><code>EDITOR</code>や<code>TZ</code>といった環境変数は<code>set -Ux</code>によってユニバーサルに設定できます.
しかし, fishが起動する前に既に環境変数が設定されている場合(ログインスクリプトやシステムの管理者によって),
それはグローバル変数として設定されます.
[変数スコープ]は&quot;inside out&quot;の検索方式をとっていて, ローカル変数, グローバル変数それからユニバーサル変数の順に変数を確認していきます.</p>
<p>これはグローバル変数の方がユニバーサール変数よりも優先順位が高いことを意味しています.</p>
<p>この問題を避けるために, fishの継承の設定を変えることが考えられます.
これが不可能なら, 次のような設定を[設定ファイル] (大抵の場合, <code>~/.config/fish/config.fish</code>)に記述してください.</p>
<pre><code class="language-fish">set -gx EDITOR vim
</code></pre>
<a class="header" href="#シンタックスハイライトの色を変えるには" id="シンタックスハイライトの色を変えるには"><h2>シンタックスハイライトの色を変えるには？</h2></a>
<p>ウェブの設定ツールの[fish_config], 若しくは環境変数の[fish_color]を変更してください.</p>
<a class="header" href="#manページの補完をアップデートするには" id="manページの補完をアップデートするには"><h2>manページの補完をアップデートするには？</h2></a>
<p>[fish_update_completions]コマンドを使ってください.</p>
<a class="header" href="#間違ってディレクトリのパスを打ってenter押したらディレクトリが移動してしまいました-何が起きたの" id="間違ってディレクトリのパスを打ってenter押したらディレクトリが移動してしまいました-何が起きたの"><h2>間違ってディレクトリのパスを打ってEnter押したらディレクトリが移動してしまいました. 何が起きたの？</h2></a>
<p>fishは与えられたコマンドが存在しなくて, かつ<code>.</code>や<code>/</code>, <code>~</code>から始まる場合,
その名前のディレクトリが存在しないか確認します.
存在すればディレクトリを移動したいのだと暗黙的に推定して実行します.
例えばホームディレクトリに移動する最速の方法は単に<code>~</code>と打ってEnterを押すだけです.</p>
<a class="header" href="#オープンコマンドが働きません" id="オープンコマンドが働きません"><h2>オープンコマンドが働きません</h2></a>
<p><code>open</code>コマンドはMIMEデータベースとGnomeやKDEが用いるファイルタイプによってデフォルトの動作を規定する,
<code>.desktop</code>ファイルを用います.
これらの環境が少なくとも1つでも存在するにも関わらずopenコマンドが動作しない場合,
これらに関係するファイルが標準的な場所にインストールされていないかもしれません.
[困ったときには]も参照ください.</p>
<a class="header" href="#fishをデフォルトシェルにするには" id="fishをデフォルトシェルにするには"><h2>fishをデフォルトシェルにするには？</h2></a>
<p>パッケージマネージャを使わずにコンパイルしてfishをインストールした場合,
まず以下のコマンドによってfishをシェルのリストに追加する必要があります.
(ただし, fishが/usr/localにインストールされていると仮定します.)</p>
<pre><code class="language-sh">echo /usr/local/bin/fish | sudo tee -a /etc/shells
</code></pre>
<p>パッケージマネージャを使ってインストールした場合は既にこの操作は行われています.</p>
<p>デフォルトシェルにするには次のコマンドを打ってください.</p>
<pre><code class="language-sh">chsh -s /usr/local/bin/fish
</code></pre>
<p>上記のパスは<code>/usr/bin/fish</code>のように変更する必要があるかもしれません.
fishがどこにインストールされているかわからない場合は<code>which fish</code>コマンドで確認してください.</p>
<p>残念なことに変更をすぐに反映することはできないので, 一度ログアウトしてから再ログインしてください.</p>
<a class="header" href="#screenを使ってるとき-プロンプトの前に変な出力がでます" id="screenを使ってるとき-プロンプトの前に変な出力がでます"><h2>screenを使ってるとき, プロンプトの前に変な出力がでます</h2></a>
<p>手っ取り早い解決策はこちらです.</p>
<p>次のコマンドをfish上で実行してください.</p>
<pre><code class="language-fish">function fish_title; end; funcsave fish_title
</code></pre>
<p>これで解決するはずです.</p>
<p>さらに何が起こっているか説明します.</p>
<p>fishはターミナルにタイトルバーメッセージを設定します.
screenがこの機能をサポートしており, ターミナルがサポートしていない場合,
screenはエスケープコードを出力しターミナルはそれを無視することなくテキストとして表示してしまいます.
fishはターミナルの種類がなんであるか判別する方法を持たないので,
fish側からこの問題を解決することはできません.
したがって, 上記のようにタイトルバーメッセージを空にするしか方法がありません.</p>
<p>fishはデフォルトのタイトルバーメッセージを持っていて,
それは<code>fish_title</code>関数が未定義のときに使われることに注意してください.
そのため単純に<code>fish_title</code>関数を削除してもうまくいきません.</p>
<a class="header" href="#グリーティングメッセージを変更するには" id="グリーティングメッセージを変更するには"><h2>グリーティングメッセージを変更するには？</h2></a>
<p><code>fish_greeting</code>変数の値を変更するか, 或いは<code>fish_greeting</code>関数を作成してください.
例えばグリーティングをなくすには次のようにします.</p>
<pre><code class="language-fish">set fish_greeting
</code></pre>
<a class="header" href="#履歴置換などが働かないのはなぜ" id="履歴置換などが働かないのはなぜ"><h2>履歴置換(<code>!$</code>など)が働かないのはなぜ？</h2></a>
<p>履歴置換は対話形式の編集が可能になる前に開発された行儀の悪いインターフェースであるからです.
fishはこのインターフェースを無くし, 代わりに完全な対話形式の履歴想起インターフェースを持ちます.
これまでの習慣を少し変える必要があります.
古い行や単語を修正したいときにはまずそれを思い出してそれから編集してください.
例えば<code>sudo !!</code>とは打たないでください. まず<code>Up</code>キーを押してそれから<code>Home</code>, 最後に<code>sudo</code>と打ってください.</p>
<p>fishの履歴想起は以下のようにとてもシンプルかつ効率的です.</p>
<ul>
<li>
<p>他のモダンなシェル同様, <code>↑</code>は最後に実行した行から順に行全体を呼び出します.
一回押すと<code>!!</code>を置き換え, <code>!-3</code>などを置き換えたい場合には次のようにしてください.</p>
<ul>
<li>ずっと前の履歴を呼び出したいとき, そのコマンドの一部を打ってから<code>↑</code>を一回或いは複数回押してください.
こうすることでその文字列を含んだコマンドに絞って呼び出すことができ,
必要な行をより早く手に入れることができます.
これは<code>!vi</code>や<code>!?bar.c</code>などの代わりになります.</li>
</ul>
</li>
<li>
<p><code>Alt+↑, Up</code>は直近に実行した行から順番に引数のみを呼び出します.
一回押すと<code>!$</code>を置き換え, <code>!!:4</code>などを置き換えたい場合は次のようにしてください.</p>
<ul>
<li>使いたい引数が履歴のずっと前にある場合, 引数の一部を打ってから<code>Alt+↑, Up</code>を押してください.
こうすることでその文字列を含んだ引数に絞って呼び出すことができ,
必要な行をより早く手に入れることができます. 試してみるととても便利なことがわかるでしょう.</li>
<li>同一の行から複数の引数を再利用したい場合(<code>!!:3*</code>のように),
全体を呼び出した後必要ない部分を削除するといいでしょう.
(<code>Alt+D</code>や<code>Alt+Backspace</code>を用いると手早く済みます.)</li>
</ul>
</li>
</ul>
<p>fishでの行の編集について, 詳細は[ドキュメント]を参照してください.</p>
<a class="header" href="#-をcd--のショートカットとして使うには" id="-をcd--のショートカットとして使うには"><h2><code>-</code>を<code>cd -</code>のショートカットとして使うには？</h2></a>
<p>2.5.0より前のfishでは<code>cd -</code>という動作をする<code>-</code>関数を定義することが可能でした.
いくつかのバグフィクスを含んだ2.5.0のリリースによって単なる<code>-</code>は無効な関数(変数も同様)となりました.
しかしアブリビエーションを使うことによって同様の操作を行うことができます.</p>
<pre><code class="language-fish">abbr -a -- - 'cd -'
</code></pre>
<a class="header" href="#アンインストールするには" id="アンインストールするには"><h2>アンインストールするには？</h2></a>
<p>万が一fishをアンインストールしたくなった場合, まずデフォルトシェルに設定されていないことを確認してください.
もしそうであれば<code>chsh -s /bin/bash</code>で変更してください.</p>
<p>次に以下の操作をしてください.
(/usr/localにfishがインストールされていると想定しています.)</p>
<pre><code class="language-sh">rm -Rf /usr/local/etc/fish /usr/local/share/fish ~/.config/fish
rm /usr/local/share/man/man1/fish*.1
cd /usr/local/bin
rm -f fish fish_indent
</code></pre>
<a class="header" href="#fishのunicode-private-use-charactersについて" id="fishのunicode-private-use-charactersについて"><h2>fishのUnicode private-use charactersについて</h2></a>
<p>fishはU+F600からU+F73Fの
<a href="http://www.unicode.org/faq/private_use.html">Unicode private-use character</a>
を内部的に使用しています.
この範囲の文字を使用した場合, Unicodeの'replacement character', U+FFFDに変換されます.
これにはインタラクティブな入力とファイルによる入力が含まれます.
(ただし実行されるプログラムには関係しません.)</p>
<a class="header" href="#fishの拡張機能を探すには" id="fishの拡張機能を探すには"><h2>fishの拡張機能を探すには？</h2></a>
<p>fishのユーザーコミュニティがfishにバンドルされるほど汎用的ではないが便利で素晴らしいスクリプトを公開しています.
プロンプトやテーマ, 便利な関数を含む, こうした拡張機能をいくつかのサードパーティのリポジトリから手に入れることができます.</p>
<ul>
<li><a href="https://github.com/jorgebucaran/fisher">Fisher</a></li>
<li><a href="https://github.com/tuvistavie/fundle">Fundle</a></li>
<li><a href="https://github.com/oh-my-fish/oh-my-fish">Oh My Fish</a></li>
<li><a href="https://github.com/justinmayer/tacklebox">Tacklebox</a></li>
</ul>
<p>これは全てのリポジトリを網羅したものではなく, fishプロジェクトとして上記のリポジトリのメリットや含まれるスクリプトについて何か意見するわけではありません.</p>
<a class="header" href="#環境変数の追加-削除をするには-1" id="環境変数の追加-削除をするには-1"><h2>環境変数の追加, 削除をするには？</h2></a>
<p>[set]コマンドを使ってください.</p>
<pre><code class="language-fish">set -x key value
set -e key
</code></pre>
<a class="header" href="#ログイン時にコマンドを実行するには-fishのbashrcは-1" id="ログイン時にコマンドを実行するには-fishのbashrcは-1"><h2>ログイン時にコマンドを実行するには？ fishの.bashrcは？</h2></a>
<p><code>~/.config/fish/config.fish</code>を編集してください.
もし存在しなければ作成することもできます.</p>
<a class="header" href="#独自のプロンプトを設定するには-1" id="独自のプロンプトを設定するには-1"><h2>独自のプロンプトを設定するには？</h2></a>
<p>プロンプトは<code>fish_prompt</code>関数の出力になります.
この関数は<code>~/.config/fish/functions/fish_prompt.fish</code>に配置してください.
簡単な例を下に示します.</p>
<pre><code class="language-fish">function fish_prompt
    set_color $fish_color_cwd
    echo -n (prompt_pwd)
    set_color normal
    echo -n ' &gt; '
end
</code></pre>
<p>Web上の設定ツール, [fish_config]を使うこともできます.
プロンプトのサンプルから選んで試すことができます.</p>
<a class="header" href="#履歴からコマンドを実行するには-1" id="履歴からコマンドを実行するには-1"><h2>履歴からコマンドを実行するには？</h2></a>
<p>コマンドの一部を入力し, それから<code>↑</code>(up)或いは<code>↓</code>(down)を押してください.
マッチした履歴を選択することができます.</p>
<a class="header" href="#サブコマンドを実行するには-バッククオートが動作しません-1" id="サブコマンドを実行するには-バッククオートが動作しません-1"><h2>サブコマンドを実行するには？ バッククオートが動作しません！</h2></a>
<p><code>fish</code>はサブコマンドを実行するために<code>()</code>を使います.</p>
<pre><code class="language-fish">for i in (ls)
    echo $i
end
</code></pre>
<a class="header" href="#pkg-configのような出力が1行の長い文字列のときどうしたらいい-1" id="pkg-configのような出力が1行の長い文字列のときどうしたらいい-1"><h2>pkg-configのような出力が1行の長い文字列のときどうしたらいい？</h2></a>
<p>他のシェルと違って, <code>fish</code>は改行時のみ置換されたコマンドを分割します.
スペースやタブ, $IFSに含まれる文字では分割されません.</p>
<p>これは次のことを意味します.</p>
<pre><code class="language-fish">echo x(printf '%s ' a b c)x
</code></pre>
<p>を実行すると<code>xa b c x</code>が出力されます.
しかし次の場合,</p>
<pre><code class="language-fish">echo x(printf '%s\n' a b c)x
</code></pre>
<p><code>xax xbx xcx</code>が出力されます.</p>
<p>ほぼ全てのケースにおいてスペース区切りは望ましくないので, この仕様は改善点であるといえます.</p>
<p>しかしながら, <code>pkg-config</code>やその周辺ツールなどではスペース区切りが必要となっています.
このような場合, <code>string split &quot; &quot;</code>を使ってください.</p>
<pre><code class="language-fish">g++ example_01.cpp (pkg-config --cflags --libs gtk+-2.0 | string split &quot; &quot;)
</code></pre>
<a class="header" href="#コマンドの終了ステータスを得るには-1" id="コマンドの終了ステータスを得るには-1"><h2>コマンドの終了ステータスを得るには？</h2></a>
<p><code>$status</code>変数を使ってください.
これは他のシェルで使われている<code>$?</code>変数を置き換えるものです.</p>
<pre><code class="language-fish">somecommand
if test $status -eq 7
    echo &quot;That's my lucky number!&quot;
end
</code></pre>
<p>もし単に成功か失敗かを知りたいだけなら, <code>if</code>のような条件構文に直接渡してください.</p>
<pre><code class="language-fish">if somecommand
    echo &quot;Command succeeded&quot;
else
    echo &quot;Command failed&quot;
end
</code></pre>
<p>より詳しくは[test]コマンドや[if]コマンドを参照してください.</p>
<a class="header" href="#一回限りの環境変数を設定するには-1" id="一回限りの環境変数を設定するには-1"><h2>一回限りの環境変数を設定するには？</h2></a>
<p><code>SOME_VAR=1 command</code>というコマンドは次のエラーを引き起こします.
<code>Unknown command &quot;SOME_VAR=1&quot;</code></p>
<p>このようなときには<code>env</code>コマンドを使ってください.</p>
<p><code>env SOME_VAR=1 command</code></p>
<p>ブロック中で次のようにローカル変数を宣言することもできます.</p>
<pre><code class="language-fish">begin
    set -lx SOME_VAR 1
    command
end
</code></pre>
<a class="header" href="#変数が定義されるているか確認するには-1" id="変数が定義されるているか確認するには-1"><h2>変数が定義されるているか確認するには？</h2></a>
<p><code>set -q var</code>コマンドを使ってください.</p>
<p>例えば<code>if set -q --$var; echo variable defined; end</code>のように使います;</p>
<p>複数の変数を確認するには'<code>and</code>や<code>or</code>の演算子を使ってください.</p>
<pre><code class="language-fish">if set -q var1; or set -q var2
    echo either variable defined
end
</code></pre>
<p>定義済みの変数は空である可能性もあることに注意してください.
次の2つのコマンドで空の変数を定義できます.
<code>set var</code> <code>set var &quot;&quot;</code></p>
<a class="header" href="#変数が空でないか確認するには-1" id="変数が空でないか確認するには-1"><h2>変数が空でないか確認するには？</h2></a>
<p><code>string length -q -- $var</code>を使ってください.
例えば<code>if string length -q -- $var; echo not empty; end</code>のように使います.</p>
<p><code>string length</code>は複数の引数のリストを個別にチェックし, 1つでも空でなければ0を返します.</p>
<pre><code class="language-fish">if string length -q -- $var1 $var2 $var3
    echo at least one of these variables is not empty
end
</code></pre>
<p>代わりに<code>test -n &quot;$var&quot;</code>を使ってください.
ただしダブルクオートで変数を括ることを忘れないでください.
例えば<code>if test -n &quot;$var&quot;; echo not empty; end</code>のように使います.
<code>test</code>コマンドはオプションとして<code>-a</code>(and)と<code>-o</code>(or)を持ちます.</p>
<pre><code class="language-fish">if test -n &quot;$var1&quot; -o -n &quot;$var2&quot; -o -n &quot;$var3&quot;
    echo at least one of these variables is not empty
end
</code></pre>
<a class="header" href="#set--uxユニバーサル変数のエクスポートが働かない-1" id="set--uxユニバーサル変数のエクスポートが働かない-1"><h2>set -Ux(ユニバーサル変数のエクスポート)が働かない？</h2></a>
<p>既に同じ名前のグローバル変数が設定されています.</p>
<p><code>EDITOR</code>や<code>TZ</code>といった環境変数は<code>set -Ux</code>によってユニバーサルに設定できます.
しかし, fishが起動する前に既に環境変数が設定されている場合(ログインスクリプトやシステムの管理者によって),
それはグローバル変数として設定されます.
[変数スコープ]は&quot;inside out&quot;の検索方式をとっていて, ローカル変数, グローバル変数それからユニバーサル変数の順に変数を確認していきます.</p>
<p>これはグローバル変数の方がユニバーサール変数よりも優先順位が高いことを意味しています.</p>
<p>この問題を避けるために, fishの継承の設定を変えることが考えられます.
これが不可能なら, 次のような設定を[設定ファイル] (大抵の場合, <code>~/.config/fish/config.fish</code>)に記述してください.</p>
<pre><code class="language-fish">set -gx EDITOR vim
</code></pre>
<a class="header" href="#シンタックスハイライトの色を変えるには-1" id="シンタックスハイライトの色を変えるには-1"><h2>シンタックスハイライトの色を変えるには？</h2></a>
<p>ウェブの設定ツールの[fish_config], 若しくは環境変数の[fish_color]を変更してください.</p>
<a class="header" href="#manページの補完をアップデートするには-1" id="manページの補完をアップデートするには-1"><h2>manページの補完をアップデートするには？</h2></a>
<p>[fish_update_completions]コマンドを使ってください.</p>
<a class="header" href="#間違ってディレクトリのパスを打ってenter押したらディレクトリが移動してしまいました-何が起きたの-1" id="間違ってディレクトリのパスを打ってenter押したらディレクトリが移動してしまいました-何が起きたの-1"><h2>間違ってディレクトリのパスを打ってEnter押したらディレクトリが移動してしまいました. 何が起きたの？</h2></a>
<p>fishは与えられたコマンドが存在しなくて, かつ<code>.</code>や<code>/</code>, <code>~</code>から始まる場合,
その名前のディレクトリが存在しないか確認します.
存在すればディレクトリを移動したいのだと暗黙的に推定して実行します.
例えばホームディレクトリに移動する最速の方法は単に<code>~</code>と打ってEnterを押すだけです.</p>
<a class="header" href="#オープンコマンドが働きません-1" id="オープンコマンドが働きません-1"><h2>オープンコマンドが働きません</h2></a>
<p><code>open</code>コマンドはMIMEデータベースとGnomeやKDEが用いるファイルタイプによってデフォルトの動作を規定する,
<code>.desktop</code>ファイルを用います.
これらの環境が少なくとも1つでも存在するにも関わらずopenコマンドが動作しない場合,
これらに関係するファイルが標準的な場所にインストールされていないかもしれません.
[困ったときには]も参照ください.</p>
<a class="header" href="#fishをデフォルトシェルにするには-1" id="fishをデフォルトシェルにするには-1"><h2>fishをデフォルトシェルにするには？</h2></a>
<p>パッケージマネージャを使わずにコンパイルしてfishをインストールした場合,
まず以下のコマンドによってfishをシェルのリストに追加する必要があります.
(ただし, fishが/usr/localにインストールされていると仮定します.)</p>
<pre><code class="language-sh">echo /usr/local/bin/fish | sudo tee -a /etc/shells
</code></pre>
<p>パッケージマネージャを使ってインストールした場合は既にこの操作は行われています.</p>
<p>デフォルトシェルにするには次のコマンドを打ってください.</p>
<pre><code class="language-sh">chsh -s /usr/local/bin/fish
</code></pre>
<p>上記のパスは<code>/usr/bin/fish</code>のように変更する必要があるかもしれません.
fishがどこにインストールされているかわからない場合は<code>which fish</code>コマンドで確認してください.</p>
<p>残念なことに変更をすぐに反映することはできないので, 一度ログアウトしてから再ログインしてください.</p>
<a class="header" href="#screenを使ってるとき-プロンプトの前に変な出力がでます-1" id="screenを使ってるとき-プロンプトの前に変な出力がでます-1"><h2>screenを使ってるとき, プロンプトの前に変な出力がでます</h2></a>
<p>手っ取り早い解決策はこちらです.</p>
<p>次のコマンドをfish上で実行してください.</p>
<pre><code class="language-fish">function fish_title; end; funcsave fish_title
</code></pre>
<p>これで解決するはずです.</p>
<p>さらに何が起こっているか説明します.</p>
<p>fishはターミナルにタイトルバーメッセージを設定します.
screenがこの機能をサポートしており, ターミナルがサポートしていない場合,
screenはエスケープコードを出力しターミナルはそれを無視することなくテキストとして表示してしまいます.
fishはターミナルの種類がなんであるか判別する方法を持たないので,
fish側からこの問題を解決することはできません.
したがって, 上記のようにタイトルバーメッセージを空にするしか方法がありません.</p>
<p>fishはデフォルトのタイトルバーメッセージを持っていて,
それは<code>fish_title</code>関数が未定義のときに使われることに注意してください.
そのため単純に<code>fish_title</code>関数を削除してもうまくいきません.</p>
<a class="header" href="#グリーティングメッセージを変更するには-1" id="グリーティングメッセージを変更するには-1"><h2>グリーティングメッセージを変更するには？</h2></a>
<p><code>fish_greeting</code>変数の値を変更するか, 或いは<code>fish_greeting</code>関数を作成してください.
例えばグリーティングをなくすには次のようにします.</p>
<pre><code class="language-fish">set fish_greeting
</code></pre>
<a class="header" href="#履歴置換などが働かないのはなぜ-1" id="履歴置換などが働かないのはなぜ-1"><h2>履歴置換(<code>!$</code>など)が働かないのはなぜ？</h2></a>
<p>履歴置換は対話形式の編集が可能になる前に開発された行儀の悪いインターフェースであるからです.
fishはこのインターフェースを無くし, 代わりに完全な対話形式の履歴想起インターフェースを持ちます.
これまでの習慣を少し変える必要があります.
古い行や単語を修正したいときにはまずそれを思い出してそれから編集してください.
例えば<code>sudo !!</code>とは打たないでください. まず<code>Up</code>キーを押してそれから<code>Home</code>, 最後に<code>sudo</code>と打ってください.</p>
<p>fishの履歴想起は以下のようにとてもシンプルかつ効率的です.</p>
<ul>
<li>
<p>他のモダンなシェル同様, <code>↑</code>は最後に実行した行から順に行全体を呼び出します.
一回押すと<code>!!</code>を置き換え, <code>!-3</code>などを置き換えたい場合には次のようにしてください.</p>
<ul>
<li>ずっと前の履歴を呼び出したいとき, そのコマンドの一部を打ってから<code>↑</code>を一回或いは複数回押してください.
こうすることでその文字列を含んだコマンドに絞って呼び出すことができ,
必要な行をより早く手に入れることができます.
これは<code>!vi</code>や<code>!?bar.c</code>などの代わりになります.</li>
</ul>
</li>
<li>
<p><code>Alt+↑, Up</code>は直近に実行した行から順番に引数のみを呼び出します.
一回押すと<code>!$</code>を置き換え, <code>!!:4</code>などを置き換えたい場合は次のようにしてください.</p>
<ul>
<li>使いたい引数が履歴のずっと前にある場合, 引数の一部を打ってから<code>Alt+↑, Up</code>を押してください.
こうすることでその文字列を含んだ引数に絞って呼び出すことができ,
必要な行をより早く手に入れることができます. 試してみるととても便利なことがわかるでしょう.</li>
<li>同一の行から複数の引数を再利用したい場合(<code>!!:3*</code>のように),
全体を呼び出した後必要ない部分を削除するといいでしょう.
(<code>Alt+D</code>や<code>Alt+Backspace</code>を用いると手早く済みます.)</li>
</ul>
</li>
</ul>
<p>fishでの行の編集について, 詳細は[ドキュメント]を参照してください.</p>
<a class="header" href="#-をcd--のショートカットとして使うには-1" id="-をcd--のショートカットとして使うには-1"><h2><code>-</code>を<code>cd -</code>のショートカットとして使うには？</h2></a>
<p>2.5.0より前のfishでは<code>cd -</code>という動作をする<code>-</code>関数を定義することが可能でした.
いくつかのバグフィクスを含んだ2.5.0のリリースによって単なる<code>-</code>は無効な関数(変数も同様)となりました.
しかしアブリビエーションを使うことによって同様の操作を行うことができます.</p>
<pre><code class="language-fish">abbr -a -- - 'cd -'
</code></pre>
<a class="header" href="#アンインストールするには-1" id="アンインストールするには-1"><h2>アンインストールするには？</h2></a>
<p>万が一fishをアンインストールしたくなった場合, まずデフォルトシェルに設定されていないことを確認してください.
もしそうであれば<code>chsh -s /bin/bash</code>で変更してください.</p>
<p>次に以下の操作をしてください.
(/usr/localにfishがインストールされていると想定しています.)</p>
<pre><code class="language-sh">rm -Rf /usr/local/etc/fish /usr/local/share/fish ~/.config/fish
rm /usr/local/share/man/man1/fish*.1
cd /usr/local/bin
rm -f fish fish_indent
</code></pre>
<a class="header" href="#fishのunicode-private-use-charactersについて-1" id="fishのunicode-private-use-charactersについて-1"><h2>fishのUnicode private-use charactersについて</h2></a>
<p>fishはU+F600からU+F73Fの
<a href="http://www.unicode.org/faq/private_use.html">Unicode private-use character</a>
を内部的に使用しています.
この範囲の文字を使用した場合, Unicodeの'replacement character', U+FFFDに変換されます.
これにはインタラクティブな入力とファイルによる入力が含まれます.
(ただし実行されるプログラムには関係しません.)</p>
<a class="header" href="#fishの拡張機能を探すには-1" id="fishの拡張機能を探すには-1"><h2>fishの拡張機能を探すには？</h2></a>
<p>fishのユーザーコミュニティがfishにバンドルされるほど汎用的ではないが便利で素晴らしいスクリプトを公開しています.
プロンプトやテーマ, 便利な関数を含む, こうした拡張機能をいくつかのサードパーティのリポジトリから手に入れることができます.</p>
<ul>
<li><a href="https://github.com/jorgebucaran/fisher">Fisher</a></li>
<li><a href="https://github.com/tuvistavie/fundle">Fundle</a></li>
<li><a href="https://github.com/oh-my-fish/oh-my-fish">Oh My Fish</a></li>
<li><a href="https://github.com/justinmayer/tacklebox">Tacklebox</a></li>
</ul>
<p>これは全てのリポジトリを網羅したものではなく, fishプロジェクトとして上記のリポジトリのメリットや含まれるスクリプトについて何か意見するわけではありません.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
